8? registers
program counter = register 0
base-of-stack-pointer = register 1
top-of-stack-pointer
stack

# program halts when PC = -1

---

CONST [regno] [value]
# store a constant value in a register

PUSH [regno]
# push the value from a register to the top of the stack, incrementing TOS

POP [regno]
# pop the value from the top of the stack to a register, decrementing TOS

LOAD [regno-read-to] [regno-address]
# read the value from (BOS + address) and store in read-to register

STORE [regno-write-to] [regno-address]
# write the value from write-to register at address (BOS + address)

COPY [regno-to] [regno-from]
# copy the value from one register to another

INPUT [reg-x] [reg-y] # to register 2
# read the value from the input spreadsheet at coordinates x,y and store it in register 2

OUTPUT [reg-x] [reg-y] # from register 2
# write the value from register 2 to the output spreadsheet at coordinates x,y

JUMPIF [pc-regno] [condition-regno]
# if the value in the condition register is zero, set the program counter to the value in the pc register
# to jump unconditionally, simply set register 0 to change the program counter, or load a constant true

ADD
MULT
AND
OR
LSHIFT
RSHIFT
EQUALS
LESSTHAN
# binary operations taking [reg-a] [reg-b]:
# compute the result of the operation on the values a,b and store in register a
# comparison ops equals/less-than store 1 or 0 for true/false

NOT [reg-no]
# perform a bitwise not on the value in a register; 16-bit int
